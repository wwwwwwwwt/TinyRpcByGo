<!--
 * @Author: zzzzztw
 * @Date: 2023-04-27 18:33:45
 * @LastEditors: Do not edit
 * @LastEditTime: 2023-06-16 16:59:48
 * @FilePath: /TinyRpcByGo/README.md
-->
# åŸºäºGoçš„ç®€æ˜“rpcæ¡†æ¶ğŸš€

ä»¿ç…§Go è¯­è¨€å®˜æ–¹çš„æ ‡å‡†åº“ net/rpcï¼Œè¿›è¡Œå¼€å‘ï¼Œå¹¶åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæ–°å¢äº†åè®®äº¤æ¢ã€æ³¨å†Œä¸­å¿ƒã€æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ã€è¶…æ—¶å¤„ç†ç­‰ç‰¹æ€§ã€‚

### ä¸»è¦ç‰¹ç‚¹ï¼š
- ğŸ”¨: ç¼–è§£ç éƒ¨åˆ†åŸºäº Jsonã€Gob æ ¼å¼
- ğŸ¯: è´Ÿè½½å‡è¡¡é‡‡ç”¨äº†å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡ç­–ç•¥ï¼Œå®ç°äº†éšæœºã€è½®è¯¢ä¸¤ç§ç®—æ³•(finish)
- â°: ä½¿ç”¨ time.After å’Œ select-chan æœºåˆ¶ä¸ºå®¢æˆ·ç«¯è¿æ¥ã€æœåŠ¡ç«¯å¤„ç†æ·»åŠ äº†è¶…æ—¶å¤„ç†æœºåˆ¶ (finish)
- â˜: å®ç°äº†ç®€æ˜“çš„æ³¨å†Œä¸­å¿ƒå’Œå¿ƒè·³æœºåˆ¶ï¼ŒåŒæ—¶æ”¯æŒäº†Etcdä½œä¸ºæ³¨å†Œä¸­å¿ƒå’ŒæœåŠ¡å‘ç°ã€‚


## å®¢æˆ·ç«¯

#### å®¢æˆ·ç«¯çš„åˆ›å»º

1. è¯·æ±‚è¿›æ¥ï¼Œåˆ°è¾¾è´Ÿè½½å‡è¡¡å®¢æˆ·ç«¯ï¼›
2. è´Ÿè½½å‡è¡¡å®¢æˆ·ç«¯è°ƒç”¨æœåŠ¡å‘ç°æ¨¡å—è·å–ä¸€ä¸ªæœåŠ¡çš„[ip:port]ï¼ŒæœåŠ¡å‘ç°æ¨¡å—é€šè¿‡è‡ªå·±çš„è´Ÿè½½å‡è¡¡ç­–ç•¥ç»™è´Ÿè½½å‡è¡¡å®¢æˆ·ç«¯è¿”å›ä¸€ä¸ª[ip:port]ï¼Œè´Ÿè½½å‡è¡¡å®¢æˆ·ç«¯é€šè¿‡è¿™ä¸ª[ip:port]ä»è‡ªèº«ç»´æŠ¤çš„mapä¸­å–å‡ºä¸ä¹‹å¯¹åº”çš„é€šä¿¡å®¢æˆ·ç«¯ã€‚
3. åˆ¤æ–­é€šä¿¡å®¢æˆ·ç«¯æ˜¯å¦å…³é—­æˆ–è€…ä¸ºç©ºï¼Œå¦‚æœæ˜¯ï¼Œåˆ™ç§»é™¤å¹¶é‡æ–°åˆ›å»ºé€šä¿¡å®¢æˆ·ç«¯ã€‚åˆ›å»ºé€šä¿¡å®¢æˆ·ç«¯çš„æ–¹æ³•æ˜¯æ”¯æŒå¤šåè®®çš„ï¼Œé€šè¿‡ ip ä¸Šçš„åè®®åç§°ï¼Œä¼ å…¥ä¸åŒçš„å®¢æˆ·ç«¯åˆ›å»ºç­–ç•¥è¿›è¡Œåˆ›å»ºã€‚å…·ä½“æ¥è¯´ï¼Œåˆ›å»ºä¸€ä¸ªé€šä¿¡å®¢æˆ·ç«¯åˆ†ä¸ºä»¥ä¸‹å‡ æ­¥ï¼š
   1. è°ƒç”¨åº“å‡½æ•° net.DialTimeout å¾—åˆ°ä¸€ä¸ªconn
   2. å¯ç”¨ä¸€ä¸ªæ–°åç¨‹ï¼Œä½¿ç”¨connå»è°ƒç”¨å®¢æˆ·ç«¯åˆ›å»ºç­–ç•¥æ–¹æ³•ï¼Œå¹¶ç»™è¿™ä¸ªåç¨‹è®¾ç½®è¶…æ—¶ï¼ˆselect chan + time afterï¼‰
   3. å®¢æˆ·ç«¯åˆ›å»ºç­–ç•¥æ–¹æ³•ä¼šæ ¹æ®è‡ªèº«çš„åè®®å»åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œå¦‚æœå†è¶…æ—¶æ—¶é—´å†…ä¼šæŠŠè¿™ä¸ªå®¢æˆ·ç«¯é€šè¿‡channelè¿”å›ç»™çˆ¶åç¨‹ã€‚å®¢æˆ·ç«¯çš„åˆ›å»ºç­–ç•¥ç›®å‰æœ‰ä¸¤ç§ï¼š
      - HTTP å®¢æˆ·ç«¯ç­–ç•¥ï¼šä¼šä¸æœåŠ¡ç«¯è¿›è¡Œä¸€æ¬¡httpçš„ CONNECT é€šä¿¡ï¼Œä½¿å¾—è¿™ä¸ª conn èƒ½å¤Ÿè¢«æœåŠ¡ç«¯åŠ«æŒï¼Œæ¥ç€å†å»åˆ›å»ºä¸€ä¸ª rpc å®¢æˆ·ç«¯ã€‚ä»è€Œä½¿å¾—è¿™ä¸ªè¿æ¥æ—¢å¯ä»¥ä¼ è¾“ HTTP è¯·æ±‚ï¼Œåˆå¯ä»¥ä¼ è¾“æˆ‘ä»¬è‡ªå®šä¹‰çš„ rpc æ¶ˆæ¯æ ¼å¼ï¼›
      - rpc å®¢æˆ·ç«¯ç­–ç•¥ï¼šä½¿ç”¨Jsonæ ¼å¼çš„æ•°æ®ä¸æœåŠ¡ç«¯è¿›è¡Œä¸¤æ¬¡æ¡æ‰‹ï¼Œä»è€Œä¸æœåŠ¡å™¨åå•†ç”¨æˆ·è‡ªå®šå¥½çš„ç¼–è§£ç å™¨ï¼Œå¹¶ä¸”å¯åŠ¨ä¸€ä¸ªæ¥æ”¶åç¨‹ã€‚

4. åˆ›å»ºå¥½çš„é€šä¿¡å®¢æˆ·ç«¯ä¼šè¢«è¿”å›ç»™è´Ÿè½½å‡è¡¡å®¢æˆ·ç«¯ï¼Œç”¨å¯¹åº”[ip:port]å­˜èµ·æ¥ï¼Œä»¥ä¾¿å¤ç”¨ã€‚ç„¶åä½¿ç”¨è¿™ä¸ªé€šä¿¡å®¢æˆ·ç«¯è¿›è¡Œrpcè°ƒç”¨

#### å®¢æˆ·ç«¯è°ƒç”¨

1. é€šä¿¡å®¢æˆ·ç«¯ä¼šå°†è¿™æ¬¡çš„è°ƒç”¨è¯·æ±‚å°è£…æˆ callï¼Œcallé‡Œé¢åŒ…å«äº†å”¯ä¸€æ ‡è¯†ï¼ˆseqï¼‰ã€è¯·æ±‚çš„æ–¹æ³•ã€å‚æ•°ã€è¿”å›å€¼ä»¥åŠä¸€ä¸ªchanï¼Œå¹¶ä¸”ä½¿ç”¨å”¯ä¸€æ ‡è¯†ï¼Œåœ¨è‡ªå·±çš„mapä¸­ç»´æŠ¤è¿™ä¸ªcall
2. ä¹‹åï¼Œä¼šå°†callä¸­çš„å…·ä½“çš„å‚æ•°å°è£…æˆåè®®è¦æ±‚çš„æ ¼å¼ï¼ˆheader + bodyï¼šheader åŒ…æ‹¬ seqã€æœåŠ¡æ–¹æ³•åã€é”™è¯¯ï¼›bodyä¸ºå‚æ•°ï¼‰ï¼Œé€šè¿‡ç¼–ç å™¨å†™ç»™æœåŠ¡ç«¯ã€‚è¿™ä¸ªè¿‡ç¨‹é€šè¿‡ call ä¸­çš„ chan å®ç°äº†å¼‚æ­¥è°ƒç”¨ï¼Œå‘é€å®Œæ¶ˆæ¯ä¹‹åï¼Œç›´æ¥è¿”å›è¿™ä¸ª  callã€‚
3. ä¸€æ¬¡è°ƒç”¨çš„è¿‡ç¨‹ï¼š
   * æ³¨å†Œï¼šå°†ç»“æ„ä½“å®ä¾‹é€šè¿‡Registerä¼ è¿›æœåŠ¡ç«¯ï¼Œå¼€ä¸€ä¸ªæ–°æœåŠ¡å®ä¾‹ï¼Œè¿™ä¸ªå®ä¾‹çš„mapä¸­ä¿å­˜ç€è¿™ä¸ªç»“æ„ä½“ï¼ˆæœåŠ¡ï¼‰çš„æ‰€æœ‰æ–¹æ³•methodï¼Œå†å°†ç»“æ„ä½“åå­—stringå’Œå¯¹åº”ç€çš„æœåŠ¡å®ä¾‹æ³¨å†Œåˆ°ä¸€ä¸ªæœåŠ¡ç«¯mapä¸­ã€‚
   * æœåŠ¡ç«¯è°ƒç”¨æ–¹æ³•ï¼šå°†ç»“æ„ä½“å®ä¾‹ä¼ è¿›æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯é€šè¿‡è§£ç ï¼Œå¾—åˆ°æ¶ˆæ¯å¤´å’Œæ¶ˆæ¯ä½“ï¼Œæ¶ˆæ¯å¤´åŒ…æ‹¬æœåŠ¡çš„åå­—ï¼ˆstringï¼Œå½¢å¦‚T.Methodï¼‰å’Œåºå·ç­‰ï¼Œæ¶ˆæ¯ä½“åŒ…æ‹¬å‚æ•°Callç»“æ„ä½“ï¼Œå†…éƒ¨åŒ…æ‹¬åºå·ï¼ŒæœåŠ¡åï¼Œå…¥å‚å’Œè¿”å›ç±»å‹ï¼ˆinterface{}ï¼‰ç­‰ã€‚é€šè¿‡å¯¹è¯·æ±‚å¤´çš„è§£æå¾—åˆ°æœåŠ¡çš„åå­—ï¼Œå†é€šè¿‡.çš„ä½ç½®åˆ†éš”å‡ºæœåŠ¡å®ä¾‹çš„åå­—stringå’Œæ–¹æ³•stringï¼Œ ä»æœåŠ¡ç«¯çš„mapä¸­å–å‡ºå¯¹åº”åå­—çš„å®ä¾‹ï¼Œå’Œä»å®ä¾‹ä¸­å–å‡ºå¯¹åº”çš„æ–¹æ³•methodã€‚ ç„¶åå¯¹è¯·æ±‚ä½“è§£æå¾—åˆ°å…¥å‚çš„ç»“æ„ä½“ï¼Œä½¿ç”¨åå°„çš„Callè°ƒç”¨æ–¹æ³•å¾—åˆ°replyvã€‚æœ€åé€šè¿‡gobç¼–ç encode è¿›buf å† flush å‘é€å›å®¢æˆ·ç«¯
   * å®¢æˆ·ç«¯æ¥æ”¶æ¶ˆæ¯ï¼šå¦‚ä¸‹

#### å®¢æˆ·ç«¯æ¥æ”¶ç»“æœ

1. åœ¨åˆ›å»ºé€šä¿¡å®¢æˆ·ç«¯çš„æ—¶å€™ï¼Œé™¤äº†ä¸æœåŠ¡ç«¯åå•†ç¼–ç ï¼Œè¿˜ä¼šå¯åŠ¨ä¸€ä¸ªæ¥æ”¶åç¨‹ã€‚
2. æ¥æ”¶åç¨‹æ­»å¾ªç¯æ¥æ”¶æœåŠ¡ç«¯çš„å“åº”ã€‚
3. æ¥æ”¶åç¨‹æ¥åœ¨æ”¶åˆ°æœåŠ¡è¿”å›çš„æ¶ˆæ¯åï¼Œä¼šå°†è¿”å›ç»“æœè§£ææˆ callï¼Œcall ä¸­çš„è¿”å›å€¼å­—æ®µå³ç”¨æ¥æ‰¿è½½æœåŠ¡ç«¯çš„å¤„ç†ç»“æœã€‚æ”¶åˆ°æ¶ˆæ¯åï¼Œä¼šç»™è¿™ä¸ªcall ä¸­çš„ chan å­—æ®µå†™å…¥â€œå¤„ç†å®Œæˆâ€çš„æ¶ˆæ¯ï¼Œå³é€šçŸ¥æŒæœ‰è¿™ä¸ª call çš„ç”¨æˆ·ï¼Œç»“æœå·²ç»æ¥æ”¶åˆ°äº†ï¼Œå¯ä»¥è¿›è¡Œä¸‹ä¸€æ­¥æ“ä½œäº†ã€‚å¤„ç†å®Œæˆä¹‹åï¼Œä¼šä»é€šä¿¡å®¢æˆ·ç«¯ä¸­ç§»é™¤è¿™ä¸ªcallï¼ˆå› ä¸ºå®ƒå·²ç»å®Œæˆäº†å®ƒçš„ä½¿å‘½ï¼‰
4. åœ¨è¿™ä¸ªå¾ªç¯è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°äº†æ¶ˆæ¯è§£æé”™è¯¯æˆ–è€…ç½‘ç»œioé”™è¯¯ï¼Œä¼šè·³å‡ºè¿™ä¸ªå¾ªç¯ï¼Œç„¶åä¸­æ–­è¿™ä¸ªé€šä¿¡å®¢æˆ·ç«¯ä¸­æ‰€æœ‰ callï¼Œå‘Šè¯‰å®ƒä»¬æœ‰é”™è¯¯å‘ç”Ÿï¼ˆå› ä¸ºå‰é¢çš„è§£ææˆ–è€…ç½‘ç»œé”™è¯¯ï¼Œä¼šå¯¼è‡´åé¢çš„æ‰€æœ‰ call éƒ½å‡ºç°é—®é¢˜ï¼Œé‚£ä¹ˆæ²¡å¿…è¦å†ç­‰æœåŠ¡å™¨çš„æ¶ˆæ¯äº†ï¼‰


---



## æœåŠ¡ç«¯

#### æ¥æ”¶è¿æ¥

1. åœ¨ä¸»åç¨‹ä¸­æ­»å¾ªç¯ Acceptï¼Œæ¯æ”¶åˆ°ä¸€ä¸ªè¿æ¥ï¼Œä¼šå¯åŠ¨ä¸€ä¸ªæ–°çš„åç¨‹å»å¤„ç†è¿™ä¸ªè¿æ¥
2. ä¸€ä¸ªæ–°çš„è¿æ¥è¿›æ¥ï¼Œè¦å»ºç«‹å¯ç”¨çš„rpcé€šä¿¡ï¼Œéœ€è¦è¿›è¡Œç¼–ç åå•†ï¼ˆè¿™ä¹Ÿæ˜¯æ–°å»ºé€šä¿¡å®¢æˆ·ç«¯æ—¶å€™æ‰€åšçš„äº‹ï¼‰ã€‚é‚£ä¹ˆæœåŠ¡ç«¯åœ¨è¿æ¥å¤„ç†åç¨‹ä¸­ï¼Œå°±éœ€è¦å…ˆå¤„ç†è¿™ä¸ªäº‹æƒ…ï¼Œç„¶åæ‰èƒ½rpcé€šä¿¡ã€‚å…·ä½“åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š
   1. è§£æç¼–ç åå•†æŠ¥æ–‡
   2. åˆ¤æ–­é­”æœ¯
   3. æ ¹æ®ç¼–ç åå•†æŠ¥æ–‡ä¸­çš„ç¼–ç å­—æ®µåˆ›å»ºå“åº”ç¼–è§£ç å™¨
   4. å“åº”å®¢æˆ·ç«¯ï¼Œé€šçŸ¥åå•†æˆåŠŸï¼ˆå®¢æˆ·ç«¯æ¥æ”¶åˆ°æˆåŠŸå“åº”ä¹‹åï¼Œæ‰èƒ½å‘é€è¯·æ±‚ï¼Œé˜²æ­¢ç²˜åŒ…ï¼‰

#### å¤„ç†è¿æ¥

1. ç¼–ç åå•†æˆåŠŸåï¼Œè¿æ¥å¤„ç†åç¨‹ä¼šè¿›å…¥æ­»å¾ªç¯æ¥æ”¶è¯¥è¿æ¥ä¸­çš„æŠ¥æ–‡ï¼ˆå› ä¸ºä¸€æ¬¡è¿æ¥ä¸­å¯ä»¥æœ‰å¤šæ¬¡è°ƒç”¨ï¼ˆheader+bodyï¼‰ï¼Œé‚£ä¹ˆéœ€è¦å°½åŠ›è€Œä¸ºï¼‰
2. å› ä¸ºä¸€ä¸ªè¿æ¥å¯èƒ½æœ‰å¤šæ¬¡è°ƒç”¨ï¼Œè€Œè€ƒè™‘åˆ°è¿™äº›è°ƒç”¨æ˜¯å¯ä»¥å¹¶å‘è¿›è¡Œï¼Œè¿æ¥å¤„ç†åç¨‹åœ¨è§£æä¸€ä¸ªheader+bodyå¯¹ä¹‹åï¼Œå°±ä¼šå¯åŠ¨ä¸€ä¸ªè¯·æ±‚å¤„ç†åç¨‹ï¼Œå»å¤„ç†è¿™ä¸ªè¯·æ±‚ï¼Œæ‰§è¡Œç›¸åº”çš„æ–¹æ³•ã€‚å¹¶ä¸”å¦‚æœæŸä¸€æ¬¡è¯»å–è§£æheader+bodyå‡ºç°äº†é”™è¯¯ï¼Œé‚£ä¹ˆå°±éœ€è¦è·³å‡ºå¾ªç¯ï¼Œå…³é—­è¿™ä¸ªè¿æ¥ï¼Œè€Œæ­¤æ—¶å‰é¢è¿˜æœ‰header+bodyçš„è°ƒç”¨æ­£åœ¨è¯·æ±‚å¤„ç†åç¨‹ä¸­è¿›è¡Œå¤„ç†ï¼Œæ‰€ä»¥ä¸èƒ½ç«‹å³å…³é—­è¿æ¥ï¼Œé‚£ä¹ˆå°±å¼•å…¥äº† WaitGroup ç­‰å¾…æ‰€æœ‰è¯·æ±‚å¤„ç†åç¨‹å¤„ç†å®Œæ¯•ä¹‹åå†å…³é—­è¿æ¥
3. æ‰§è¡Œä¸€ä¸ªæ–¹æ³•çš„æ—¶é—´å¯é•¿å¯çŸ­ï¼Œåœ¨è¯·æ±‚å¤„ç†åç¨‹ä¸­ï¼Œä¹Ÿé‡‡ç”¨äº†ï¼ˆåç¨‹è°ƒç”¨ + select chan + time after çš„è¶…æ—¶æœºåˆ¶ï¼‰
4. å› ä¸ºè°ƒç”¨å®Œåï¼Œå†™ç»™å®¢æˆ·ç«¯çš„è¿”å›å€¼ä¹Ÿæ˜¯header+bodyï¼Œé‚£ä¹ˆå°±éœ€è¦ä¿è¯åœ¨è¿™ä¸ªè¿æ¥ä¸­header+bodyæ˜¯æˆå¯¹å†™å…¥çš„ï¼Œä¸èƒ½å‡ºç°äº¤ç»‡ï¼Œæ‰€ä»¥éœ€è¦ç”¨é”æ§åˆ¶header+bodyå†™å›çš„åŸå­æ€§ã€‚

### æœåŠ¡


1. å› ä¸ºå®¢æˆ·ç«¯çš„è¯·æ±‚æ˜¯ service.methodï¼Œæ‰€ä»¥æˆ‘ä»¬åˆ†åˆ«å®šä¹‰äº† service ç»“æ„ä½“å’Œ methodType ç»“æ„ä½“åˆ†åˆ«ç”¨æ¥ä¿å­˜â€œä¸€ä¸ªç”¨æ¥æä¾›æœåŠ¡çš„ç»“æ„ä½“â€å’Œâ€œå…¶æ–¹æ³•è¢«è°ƒç”¨æ‰€éœ€è¦â€œçš„å„é¡¹ä¿¡æ¯
2. service å¯¹è±¡ä»£è¡¨ç€ä¸€ä¸ªæä¾›æœåŠ¡çš„å¯¹è±¡ï¼ŒmethodType å¯¹è±¡ä»£è¡¨ç€è¿™ä¸ªæä¾›æœåŠ¡çš„å¯¹è±¡çš„ä¸€ä¸ªæ–¹æ³•ã€‚æ‰€ä»¥ service ä»¥ map æŒæœ‰å¤šä¸ª methodTypeã€‚
3. æä¾›äº†å°†ä¸€ä¸ªç»“æ„ä½“å¯¹è±¡è½¬å˜æˆ serviceå¯¹è±¡ï¼Œå…¶ä¸­çš„åˆè§„æ–¹æ³•è½¬å˜æˆ methodType çš„å‡½æ•°ã€‚ï¼ˆåˆè§„çš„æ–¹æ³•çš„ç­¾ååªèƒ½æœ‰ä¸¤ä¸ªå…¥å‚ï¼Œå‰ä¸€ä¸ªä»£è¡¨å‚æ•°ï¼Œåä¸€ä¸ªä»£è¡¨è¿”å›å€¼ï¼Œå’Œä¸€ä¸ªé”™è¯¯è¿”å›å€¼ï¼‰
4. å°† service é›†æˆè¿› Serverï¼Œä½¿å¾— Serverèƒ½å¤Ÿæ³¨å†Œ serviceï¼ŒæŒæœ‰å¤šä¸ª serviceï¼Œå¹¶ä¸”åœ¨å¤„ç†è¯·æ±‚æ—¶ï¼Œèƒ½å¤Ÿè°ƒç”¨åˆ°å¯¹åº” service çš„ method ä¸Š
5. é€šè¿‡ ```method.Func.Call([]reflect.Value{s.rcvr, argv, replyv})```è°ƒç”¨å¯¹è±¡çš„æ–¹æ³•

---



## æ³¨å†Œä¸­å¿ƒ

### ç®€æ˜“æ³¨å†Œä¸­å¿ƒ

1. è¿™ä¸ªæ³¨å†Œä¸­å¿ƒç»´æŠ¤äº†ä¸€ä¸ª [æœåŠ¡å™¨åœ°å€ -> æœåŠ¡å™¨åœ°å€ + è¯¥æœåŠ¡ä¸Šä¸€æ¬¡çš„å¿ƒè·³æ—¶é—´] çš„ mapï¼Œå¹¶ä¸”é€šè¿‡å®ç° http.Handler æ¥å£ï¼Œå¯¹å¤–æä¾› Http æœåŠ¡ï¼Œè¿™æ ·æ¯ä¸ªæœåŠ¡å™¨å¯ä»¥é€šè¿‡ POST è¯·æ±‚å‘é€å¿ƒè·³ã€æœåŠ¡å‘ç°æ¨¡å—é€šè¿‡ GET è¯·æ±‚æ‹‰å–æ‰€æœ‰å¯ç”¨æœåŠ¡å™¨çš„åœ°å€ã€‚
2. æ³¨å†Œä¸­å¿ƒåœ¨å“åº”æœåŠ¡å‘ç°æ¨¡å—çš„GETè¯·æ±‚æ—¶ï¼Œä¼šéå†ä¸€éè‡ªå·±ç»´æŠ¤çš„æœåŠ¡åˆ—è¡¨ï¼Œå‰”é™¤æ‰å·²ç»è¶…æ—¶çš„æœåŠ¡ï¼Œç„¶åé€šè¿‡ HTTP è‡ªå®šä¹‰å¤´ï¼Œè¿”å›æ‰€æœ‰å­˜æ´»çš„æœåŠ¡åœ°å€ã€‚
3. æ­¤å¤–ï¼Œè¿˜æš´éœ²äº†å¯¹å¤–çš„ Heartbeat å‡½æ•°ï¼Œä½¿å¾—æœåŠ¡å¯ä»¥ä½¿ç”¨è¯¥å‡½æ•°å‘æŒ‡å®šæ³¨å†Œä¸­å¿ƒå‘é€æŒ‡å®šæœåŠ¡çš„å¿ƒè·³

### Etcdæ³¨å†Œä¸­å¿ƒ

<center>

![](/img/etcd.png)

</center>

1. ä½¿ç”¨æ—¶éœ€è¦å¼€å¦ä¸€ä¸ªç»ˆç«¯ å¹¶æ‰“å¼€ä¸€ä¸ªectdèŠ‚ç‚¹ï¼Œé»˜è®¤ç›‘å¬2379ç«¯å£ã€‚
#### ä»£ç é€»è¾‘
1. åˆ©ç”¨etcdæš´éœ²çš„clientv3æ¥å£ï¼Œåˆ›å»ºclientå¯¹è±¡ï¼Œä¸ºå…¶ç»‘å®šç›‘å¬åœ°å€å’Œè¶…æ—¶æ—¶é—´ã€‚
```go
func NewEtcdClient(addr []string, timeout time.Duration) *EtcdClient {
	if timeout == 0 {
		timeout = defaultTimeout - time.Duration(1)*time.Minute
	}

	client, err := clientv3.New(clientv3.Config{
		Endpoints:   addr,
		DialTimeout: timeout,
	})

	if err != nil {
		log.Printf("rpc etcd: cannot connect to %s: err: %s", addr, err)
		return nil
	}
	return &EtcdClient{client: client, timeout: timeout}
}
```

2. keyä¸ºç›‘å¬åœ°å€ï¼Œvalueä¸ºç›‘å¬åœ°å€å…·ä½“çš„æœåŠ¡ï¼Œåˆ©ç”¨ç§Ÿçº¦å°†å…¶ç»‘å®šç»™æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„clientå¯¹è±¡ï¼Œå¹¶æ— é™æœŸå®šæ—¶å‘é€å¿ƒè·³ç»™keyç»­çº¦ï¼Œè¿™é‡Œå¦‚æœåšçš„æ›´ç²¾ç»†çš„è¯å¯ä»¥åŠ ä¸€äº›é”™è¯¯åˆ¤æ–­ï¼Œç„¶ååˆ©ç”¨ä¸Šä¸‹æ–‡ctxæ¥å–æ¶ˆï¼Œæˆ–ä½¿ç”¨keepaliveonceï¼Œæ‰‹åŠ¨å®šæ—¶å‘å¿ƒè·³
```go
//ç”¨äºåˆ›å»ºç§Ÿçº¦ï¼Œ
func (e *EtcdClient) Put(key, value string) error {

	//è·å–ç§Ÿçº¦å¯¹è±¡
	lease := clientv3.NewLease(e.client)
	//åˆ›å»ºè¶…æ—¶ç§Ÿçº¦

	leaseGrantResponse, err := lease.Grant(context.Background(), int64(e.timeout/time.Second))

	if err != nil {
		return err
	}

	//å°†ç§Ÿçº¦ç»‘å®šåˆ°kvå¯¹è±¡ä¸­å»
	_, err = e.client.Put(context.TODO(), key, value, clientv3.WithLease(leaseGrantResponse.ID))
	if err != nil {
		return err
	}

	//åˆ©ç”¨å¿ƒè·³ç»™key ç»­ç§Ÿ
	keepAlive, err := lease.KeepAlive(context.TODO(), leaseGrantResponse.ID)

	// æ¶ˆè€—ç»­çº¦æœåŠ¡ç«¯è¿”å›çš„æ¶ˆæ¯
	go leaseKeepAlive(keepAlive)
	return nil
}
```

### æœåŠ¡å‘ç°

#### ç®€æ˜“æœåŠ¡å‘ç°æ¨¡å—

1. ç®€æ˜“æœåŠ¡å‘é€æ¨¡å—ï¼Œå†…éƒ¨ç»´æŠ¤äº†ä»æ³¨å†Œä¸­å¿ƒå…¨é‡æ‹‰å–çš„æœåŠ¡å™¨åœ°å€
2. å¹¶ä¸”åœ¨æ¯æ¬¡ Get æœåŠ¡å™¨åœ°å€æ—¶ï¼Œä¼šä½¿ç”¨ Refresh æ–¹æ³•æ ¹æ®è®¾å®šå¥½çš„è¶…æ—¶æ—¶é—´ï¼Œåˆ¤æ–­æ˜¯å¦è¦å»æ³¨å†Œä¸­å¿ƒå…¨é‡æ‹‰å–ä¸€æ¬¡
3. æ›´æ–°å®Œæ³¨å†Œä¸­å¿ƒåœ°å€åï¼Œä¼šé€šè¿‡è®¾å®šå¥½çš„è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œä»æœåŠ¡å™¨åœ°å€åˆ—è¡¨ä¸­è¿”å›ä¸€ä¸ªé€‰ä¸­çš„æœåŠ¡å™¨åœ°å€ç»™é€šä¿¡å®¢æˆ·ç«¯

#### EtcdæœåŠ¡å‘ç°æ¨¡å—

1. å®¢æˆ·ç«¯ä¸etcd 2379èŠ‚ç‚¹è¿›è¡Œäº¤äº’çš„æ¨¡å—ï¼Œåˆ©ç”¨clientv3æä¾›çš„Getæ–¹æ³•å¾—åˆ°å¥åº·çš„æœåŠ¡å™¨èŠ‚ç‚¹åœ°å€ï¼Œwatchå¯ä»¥è·å¾—æˆ‘ä»¬ç›‘æ§ç›®å½•ä¸‹çš„å˜åŠ¨ï¼Œå¦‚åœ¨æˆ‘ä»¬ç›‘æ§çš„ç›®å½•ä¸‹æ–°å¢ä¸€ä¸ªæœåŠ¡ï¼ŒåŸç†æ˜¯ï¼Œetcdä¼šåˆ›å»ºä¸€ä¸ªwatcherå¯¹è±¡ï¼Œwatcherå¯¹è±¡å’Œæˆ‘ä»¬ç›‘æ§çš„æœåŠ¡ç«¯ä¿æŒä¸€ä¸ªé•¿è¿æ¥ï¼Œå¹¶åœ¨é”®çš„æ›´æ”¹æ—¶é€šçŸ¥ï¼Œå°†ç°åœ¨è§‚å¯Ÿåˆ°çš„ç‰ˆæœ¬å·å¹¶æ¯”è¾ƒè‡ªå·±è§‚å¯Ÿçš„èµ·å§‹ç‚¹ç‰ˆæœ¬å·åšå¯¹æ¯”, å½“æˆ‘ä»¬ç›‘æ§çš„ç›®å½•æ”¹å˜æ—¶ï¼Œé€šçŸ¥æˆ‘ä»¬æ”¹å˜çš„é”®å’Œå…¶valã€‚
```go
//watcher
func (e *EtcdRegistryDiscory) watchProviders(ctx context.Context) {
	watchChan := clientv3.NewWatcher(e.client).Watch(context.TODO(), config.EtcdProviderPath, clientv3.WithPrefix())

	select {
	case <-watchChan:
		for _ = range watchChan {
			// è¿™é‡Œå¯ä»¥åšå¾—æ›´ç²¾ç»†ï¼Œå› ä¸º etcd ä¼šç»™å‡ºå˜åŒ–çš„ keyï¼Œæˆ‘ä»¬æƒä¸”ç®€å•å¤„ç†
			// ç»“ç‚¹äº§ç”Ÿäº†å˜åŒ–ï¼Œå°±ä»æœåŠ¡å™¨æ‹‰å–
		}
		e.refreshFromEtcd()
	case <-ctx.Done():
	}
}
//è·å¾—ç°åœ¨æœ€æ–°çš„æœåŠ¡ç«¯åœ°å€
func (e *EtcdRegistryDiscory) refreshFromEtcd() error {
	resp, err := e.client.Get(context.Background(), config.EtcdProviderPath, clientv3.WithPrefix())

	if err != nil {
		log.Println("rpc&&etcd discovery: refresh err:", err)
		return err
	}

	e.servers = make([]string, 0, resp.Count)

	for i, _ := range resp.Kvs {
		e.servers = append(e.servers, string(resp.Kvs[i].Value))
	}
	e.lastUpdate = time.Now()
	return nil
}

```
---

\*************************************************************************************************************\*  
ä»¥ä¸‹ä¸ºå¼€å‘æ—¶é‡åˆ°çš„é—®é¢˜:
1.  bug1:å®¢æˆ·ç«¯ä¸€å¼€å§‹å‘é€jsonæ ¼å¼Optionæ—¶ 

```go

/*
| Option{MagicNumber: xxx, CodecType: xxx} | Header{ServiceMethod ...} | Body interface{} |
| <------      å›ºå®š JSON ç¼–ç       ------>  | <-------   ç¼–ç æ–¹å¼ç”± CodeType å†³å®š   ------->|
åœ¨ä¸€æ¬¡è¿æ¥ä¸­ï¼ŒOptionå›ºå®šåœ¨æŠ¥æ–‡æœ€å‰é¢headerå’Œbodyå¯èƒ½ä¼šæœ‰å¤šä¸ª
| Option | Header1 | Body1 | Header2 | Body2 | ...
*/

å®¢æˆ·ç«¯å‘é€ï¼š
_ = json.NewEncoder(conn).Encode(tinyrpc.DefaultOption)
cc := codec.NewGobCodec(conn)

æœåŠ¡ç«¯è§£ç 

if err := json.NewDecoder(conn).Decode(&opt); err != nil {
log.Println("rpv server: options error", err)
return
}

ç”±äºæ²¡æœ‰ç¡®å®šè¾¹ç•Œï¼Œå½“ç¼“å†²åŒºæœ‰å¤šæ¡æ¶ˆæ¯å †ç§¯æ—¶ï¼Œå¯èƒ½jsonæŠŠHeaderçš„å†…å®¹è¯»å‡ºï¼Œå¯¼è‡´Headerå†…å®¹ç¼ºå¤±ï¼Œå½¢æˆé˜»å¡


```

* serverç«¯è§£æOptionçš„æ—¶å€™å¯èƒ½ä¼šç ´ååé¢RPCæ¶ˆæ¯çš„å®Œæ•´æ€§ï¼Œå½“å®¢æˆ·ç«¯æ¶ˆæ¯å‘é€è¿‡å¿«æœåŠ¡ç«¯æ¶ˆæ¯ç§¯å‹æ—¶ï¼ˆä¾‹ï¼šOption|Header|Body|Header|Bodyï¼‰ï¼ŒæœåŠ¡ç«¯ä½¿ç”¨jsonè§£æOptionï¼Œjson.Decode()è°ƒç”¨conn.read()è¯»å–æ•°æ®åˆ°å†…éƒ¨çš„ç¼“å†²åŒºï¼ˆä¾‹ï¼šOption|Headerï¼‰ï¼Œæ­¤æ—¶åç»­çš„RPCæ¶ˆæ¯å°±ä¸å®Œæ•´äº†(Body|Header|Body)ã€‚  
ç›®å‰ä»£ç ä¸­å®¢æˆ·ç«¯ç®€å•çš„ä½¿ç”¨time.sleep()æ–¹å¼éš”ç¦»åè®®äº¤æ¢é˜¶æ®µä¸RPCæ¶ˆæ¯é˜¶æ®µï¼Œå‡å°‘è¿™ç§é—®é¢˜å‘ç”Ÿçš„å¯èƒ½ã€‚ï¼ˆfix bugï¼‰  
ï¼ˆnewï¼‰é€šè¿‡å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¸¤æ¬¡æ¡æ‰‹ï¼Œç¡®ä¿æœåŠ¡ç«¯å°†å®¢æˆ·ç«¯å‘æ¥çš„optionå­—æ®µè¢«å¤„ç†å®Œï¼Œå®¢æˆ·ç«¯å†å‘é€| Header{ServiceMethod ...} | Body interface{} | é˜²æ­¢ç²˜åŒ…

2.  Callçš„è®¾è®¡

* ä¸€ä¸ªå…¸å‹çš„å‡½æ•°è¿œç¨‹è°ƒç”¨å½¢å¼

```go

func (t *T)MethodName(argType *T1, replyType *T2)error

```
æŠŠæ‰€æœ‰éœ€è¦çš„ä¿¡æ¯å°è£…è¿›Call

```go
type Call struct {
	Seq           uint64 // æ¶ˆæ¯çš„åºå·ï¼Œ ä¸æ–­å¢é•¿
	ServiceMethod string //æœåŠ¡ç«¯æ³¨å†Œè¿‡çš„æ–¹æ³•
	Args          interface{} // å‚æ•°
	Reply         interface{} // è¿”å›çš„ç»“æœ
	Error         error
	Done          chan *Call // ä¸ºäº†å¯ä»¥å¼‚æ­¥è°ƒç”¨ï¼Œå®šä¹‰ç®¡é“ï¼Œå½“è°ƒç”¨ç»“æŸåé€šçŸ¥è°ƒç”¨æ–¹ï¼Œ 
}
```


* å…³äºå®¢æˆ·ç«¯æ¥å£Callä¸Go

	Call æ˜¯åŒæ­¥æ¥å£ï¼Œå…·ä½“ä½¿ç”¨å†mainä¸­æœ‰æ‰€å±•ç°ï¼Œä¼šç­‰å¾…æ‰§è¡Œç»“æœè¿”å›åå†è¿›è¡Œæ‰§è¡Œ  
	Go ä¸ºå¼‚æ­¥æ¥å£ï¼Œå…·ä½“ä½¿ç”¨åœºæ™¯å¦‚ä¸‹

```go
//--------------------------
//Call

go func(i int) {
	defer wg.Done()
	args := fmt.Sprintf("geerpc req %d", i)
	var reply string
	if err := client.Call("Foo.Sum", args, &reply); err != nil {
		log.Fatal("call Foo.Sum error:", err)
	}
	log.Println("reply:", reply)
}(i)

//--------------------------
//Go
call := client.Go( ... )
//æ–°å¯åŠ¨åç¨‹ï¼Œå¼‚æ­¥ç­‰å¾…
go func(call *Call) {
	select {
		<-call.Done:
			# do something
		<-otherChan:
			# do something
	}
}(call)

otherFunc() // ä¸é˜»å¡ï¼Œç»§ç»­æ‰§è¡Œå…¶ä»–å‡½æ•°ã€‚
```


3.  é€šè¿‡åå°„å®ç°ç»“æ„ä½“ä¸æœåŠ¡çš„æ˜ å°„å…³ç³»
  * RPC æ¡†æ¶çš„ä¸€ä¸ªåŸºç¡€èƒ½åŠ›æ˜¯ï¼šåƒè°ƒç”¨æœ¬åœ°ç¨‹åºä¸€æ ·è°ƒç”¨è¿œç¨‹æœåŠ¡ã€‚é‚£å¦‚ä½•å°†ç¨‹åºæ˜ å°„ä¸ºæœåŠ¡å‘¢ï¼Ÿé‚£ä¹ˆå¯¹ Go æ¥è¯´ï¼Œè¿™ä¸ªé—®é¢˜å°±å˜æˆäº†å¦‚ä½•å°†ç»“æ„ä½“çš„æ–¹æ³•æ˜ å°„ä¸ºæœåŠ¡ã€‚  
  * å¯¹ net/rpc è€Œè¨€ï¼Œä¸€ä¸ªå‡½æ•°éœ€è¦èƒ½å¤Ÿè¢«è¿œç¨‹è°ƒç”¨ï¼Œéœ€è¦æ»¡è¶³å¦‚ä¸‹äº”ä¸ªæ¡ä»¶ï¼š
  * the methodâ€™s type is exported. â€“ æ–¹æ³•æ‰€å±ç±»å‹æ˜¯å¯¼å‡ºçš„ã€‚
  * the method is exported. â€“ æ–¹å¼æ˜¯å¯¼å‡ºçš„
  * the method has two arguments, both exported (or builtin) types. â€“ ä¸¤ä¸ªå…¥å‚ï¼Œå‡ä¸ºå¯¼å‡ºæˆ–å†…ç½®ç±»å‹ã€‚
  * the methodâ€™s second argument is a pointer. â€“ ç¬¬äºŒä¸ªå…¥å‚å¿…é¡»æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚
  * the method has return type error. â€“ è¿”å›å€¼ä¸º error
  
```go
  func (t *T) MethodName(argType T1, replyType *T2) error
```

é€šè¿‡åå°„ï¼Œå¯ä»¥è·å–æŸä¸ªç»“æ„ä½“æ‰€æœ‰çš„æ–¹æ³•ï¼Œå¹¶ä¸”é€šè¿‡æ–¹æ³•å¯ä»¥çŸ¥é“å…¶æ‰€æœ‰çš„å‚æ•°ç±»å‹å’Œè¿”å›å€¼ï¼Œå…·ä½“ç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
func main() {
	var wg sync.WaitGroup
	typ := reflect.TypeOf(&wg)
	for i := 0; i < typ.NumMethod(); i++ {
		method := typ.Method(i)
		argv := make([]string, 0, method.Type.NumIn())
		returns := make([]string, 0, method.Type.NumOut())
		// j ä» 1 å¼€å§‹ï¼Œç¬¬ 0 ä¸ªå…¥å‚æ˜¯ wg è‡ªå·±ã€‚
		for j := 1; j < method.Type.NumIn(); j++ {
			argv = append(argv, method.Type.In(j).Name())
		}
		for j := 0; j < method.Type.NumOut(); j++ {
			returns = append(returns, method.Type.Out(j).Name())
		}
		log.Printf("func (w *%s) %s(%s) %s",
			typ.Elem().Name(),
			method.Name,
			strings.Join(argv, ","),
			strings.Join(returns, ","))
    }
}

è¿è¡Œçš„ç»“æœæ˜¯ï¼š
func (w *WaitGroup) Add(int)
func (w *WaitGroup) Done()
func (w *WaitGroup) Wait()

```

4. è®¾å®šå®šæ—¶å™¨è¶…æ—¶æ—¶ï¼Œé€ æˆäº†ç®¡é“é˜»å¡å†…å­˜æ³„æ¼

å½“ä¸»çº¿ç¨‹è¶…æ—¶æ—¶ï¼Œæ— ç¼“å†²ç®¡é“å†…æ•°æ®æ— æ³•è¢«æ‹¿èµ°ï¼Œå¯¼è‡´é˜»å¡å†…å­˜æ³„æ¼

```go
	/*go func() {
		client, err := f(conn, opt) // è‹¥ä¸»çº¿ç¨‹è¶…æ—¶ç»“æŸäº†ï¼Œè¿™ä¸ªchä¸­çš„æ•°æ®æ²¡è¢«æ‹¿èµ°å°†è¢«é˜»å¡ï¼Œé€ æˆå†…å­˜æ³„æ¼
		ch <- clientResult{client: client, err: err}
	}()*/

   // ch <- cs
   // è¿™é‡Œä¼šæœ‰å†…å­˜æ³„éœ²çš„éšæ‚£ï¼šè¶…æ—¶ä¹‹åï¼Œç”±äºæ²¡æœ‰ <-chï¼Œè¿™ä¸ªå­åç¨‹ä¼šé˜»å¡åœ¨ ch <- cs
   // æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼š
   //    1. æŠŠ ch æ”¹æˆç¼“å†²å½¢å¼çš„ channelï¼šch := make(chan clientResult, 1)
   //    2. ä½¿ç”¨ select + defaultï¼Œç»“æœä¸èƒ½æ”¾å…¥ ch çš„è¯ï¼Œå°±èµ° default
   // æ ·ä¾‹ä»£ç  ï¼š
   // // ch := make(chan struct{}, 1)
   //	ch := make(chan struct{})
   //	timeout := time.Second * 2
   //	go func() {
   //		time.Sleep(time.Second * 4)
   //		/*select {
   //		case ch <- struct{}{}:
   //		default:
   //		}*/
   //		ch <- struct{}{}
   //		fmt.Println("åç¨‹æ­£å¸¸é€€å‡º")
   //	}()
   //	select {
   //	case <-time.After(timeout):
   //		fmt.Println("è¶…æ—¶")
   //	case <-ch:
   //		fmt.Println("æ­£å¸¸é€€å‡º")
   //	}
   //	for{
   //
   //	}

    go func(){
		client, err := f(conn, opt)
		//ch <- clientResult{client: client, err: err}// è‹¥ä¸»çº¿ç¨‹è¶…æ—¶ç»“æŸäº†ï¼Œè¿™ä¸ªchä¸­çš„æ•°æ®æ²¡è¢«æ‹¿èµ°å°†è¢«é˜»å¡ï¼Œé€ æˆå†…å­˜æ³„éœ²
		// ä¿®æ”¹ä¸ºèƒ½æ”¾è¿›ç®¡é“å°±æ”¾ï¼Œä¸èƒ½å°±èµ°default
		select {
		case ch <- clientResult{client: client, err: err}:
		default:
		}
    }()

	if opt.ConnectTimeout == 0 {
		result := <-ch
		return result.client, result.err
	}

	select {
	case <-time.After(opt.ConnectTimeout):
		return nil, fmt.Errorf("rpc client: connect timeout: expect within %s", opt.ConnectTimeout)
	case result := <-ch: 
		return result.client, result.err
	}

```



åå°„å…³é”®å‡½æ•°æ€»ç»“

```
// è·å–å€¼
v.Int():   Int, Int8, Int16, Int32, Int64: 
v.Unit():
v.String():
v.Bool():

Slice, Array:
	i < v.Len()
	v.Index(i)  // ä¿®æ”¹iä½çš„elemï¼Œä¼šåé¦ˆåˆ°æ•´ä¸ªarrayæˆ–sliceä¸Šå—ï¼Ÿ

Struct:
	i < v.NumField()
	v.Field(i)  // Valueç±»å‹çš„i'th field of the struct vï¼Œ åŒ…å«æ•´ä¸ªfieldNameå’ŒfieldValueå—ï¼Ÿ
	v.Type().Field(i).Name --> fieldName
	v.FieldByName("xxx")

Map:
	range _, key := v.MapKeys()  --> key
	v.MapIndex(key)              --> valueï¼Œè¿˜æ˜¯æ•´ä½“ï¼Ÿ

Ptr:
	v.Elem()        --> *p

Interface:
	v.Elem()        --> dynamic value


// è®¾ç½®å€¼
v.Set(reflect.Zero(v.Type))
v.SetString()
v.SetInt()

array:
	v.Index(i)
Slice:
	item := reflect.New(v.Type().Elem()).Elem()  // New()åˆ›å»ºä¸€ä¸ªå…ƒç´ ç±»å‹çš„æŒ‡é’ˆï¼Œå†Elemè·å–å˜é‡
	v.Set(reflect.Append(v, item))
	
Map:
	key := reflect.New(v.Type().Key()).Elem() // Type().Key()è¿”å›kindä¸ºmapçš„ä¸­çš„å…ƒç´ type
	value := reflect.New(v.Type().Elem()).Elem()
	v.SetMapIndex(key, value)
	

// è·å–æ–¹æ³•
i < v.NumMethod()
v := reflect.ValueOf(x)
t := v.Type()
methType := v.Method(i).Type()
t.Method(i).Name
methType.String()

```